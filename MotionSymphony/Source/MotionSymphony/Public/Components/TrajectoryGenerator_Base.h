// Copyright 2020 Kenneth Claassen. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/ActorComponent.h"
#include "MotionDataAsset.h"
#include "Data/Trajectory.h"
#include "Data/InputProfile.h"
#include "TrajectoryGenerator_Base.generated.h"

class UCameraComponent;

UCLASS(BlueprintType, Category = "Motion Matching", meta = (BlueprintSpawnableComponent))
class MOTIONSYMPHONY_API UTrajectoryGenerator_Base : public UActorComponent
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UMotionDataAsset* MotionData;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = 0.0f, ClampMax = 1.0f))
	float RecordingFrequency;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = 1.0f))
	float SampleRate;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	bool bFlattenTrajectory;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Debug)
	bool bDebugRandomInput;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Debug)
	FVector2D DebugTimeIntervalRange;

	//Trajectory
	UPROPERTY()
	FTrajectory Trajectory;

	UPROPERTY()
	FVector2D InputVector;

protected:
	//Past Trajectory
	float MaxRecordTime;
	float TimeSinceLastRecord;
	TArray<FVector> RecordedPastPositions; //Todo: Make these circular buffers
	TArray<float> RecordedPastRotations;
	TArray<float> RecordedPastTimes;
	float CumActiveTime;

	//Tracking
	float TimeHorizon;
	float TimeStep;
	int TrajectoryIterations;
	float CurFacingAngle;
	
	TArray<FVector> TrajPositions;
	TArray<float> TrajRotations;
	TArray<float> TrajTimes;

	//Debug
	float TimeSinceLastDebugInputChange;
	float TimeToChangeDebugInput;
	FVector2D DebugInputVector;

	//Character
	AActor* OwningActor;

	FInputProfile* InputProfile;

private:
	bool bExtractedThisFrame;
	FTransform CacheActorTransform;

public:	
	// Sets default values for this component's properties
	UTrajectoryGenerator_Base();

public:
	/** Sets the X axis of the trajectory input vector */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	void SetTrajectoryInputX(float XAxisValue);

	/** Sets the Y axis of the trajectory input vector */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	void SetTrajectoryInputY(float YAxisValue);

	/** Sets the Input vector for the trajectory generator */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	void SetTrajectoryInput(float XAxisValue, float YAxisValue);

	/** Sets the Input profile to use */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	void SetInputProfile(UPARAM(ref) FInputProfile& InInputProfile);

	/** Clears the Input profile from the trajectory generator so that input will no longer
	be remapped */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	void ClearInputProfile();

	/** Returns the last trajectory that was generated by this trajectory generator*/
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory")
	FTrajectory& GetCurrentTrajectory();

	/** Debug function that can be used to draw the trajectory*/
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Debug")
	void DrawTrajectoryDebug(FVector DrawOffset);

	/** Checks if the Trajectory is in an idle state. This means it has no
	magnitude in the past or future and no varying facing angles */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory")
	bool IsIdle();

	/** Returns true if the input vector is greater than zero magnitude at the time of 
	callsing */
	UFUNCTION(BlueprintCallable, Category = "MotionMatching/Trajectory/Input")
	bool HasMoveInput();

	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
	FActorComponentTickFunction* ThisTickFunction) override;

	virtual void BeginPlay() override;

protected:
	
	void RecordPastTrajectory(float DeltaTime);
	virtual void UpdatePrediction(float DeltaTime);
	virtual void ApplyDebugInput(float DeltaTime);

private:
	virtual void Setup(TArray<float>& InTrajTimes);
	void ExtractTrajectory();
	inline void ClampInputVector();
};
